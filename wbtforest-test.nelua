require 'wbtforest'
require 'nester'

-- Customize nester configuration.
nester.stop_on_fail = false

nester.describe('wbtforest', function()
  nester.before(function(name: string)
    -- This function is run before every test.
  end)

  nester.describe('wbtforest funs', function() -- Describe blocks can be nested.
    nester.it('instanciating', function()
      local forest: wbtforest(integer, integer)
      expect.equal(#forest, 0) -- creates doubly linked list
      expect.equal(#forest, 0) -- uses doubly linked list
    end)

    nester.it('insert & get', function()
      local forest: wbtforest(integer, integer)
      expect.equal(#forest, 0)
      local wbt1 <close> = forest:makewbtmap() -- : wbtmapT
      expect.equal(#forest, 1)
      local wbt2 <close> = forest:makewbtmap() -- : wbtmapT
      expect.equal(#forest, 2)
      local wbt3 <close> = wbt2:insert(42,-42)
      expect.equal(wbt3:get(42,-999), -42)
      expect.equal(wbt3:get(41,-999), -999)
      expect.equal(wbt2:get(42,-999), -999)
      forest:destroy()
    end)

    nester.it('grow manual', function()
      local forest: wbtforest(integer, integer, nil, GeneralAllocator) <close>
      --PRINTF!("About to make\n")
      local wbt1 <close> = forest:makewbtmap() -- : *wbtmapT NG?
      --PRINTF!("About to loop\n")
      for i = 1, 240 do
        local wbt2 = wbt1:insert(i,-i) -- : *wbtmapT
        --wbt1 = wbt1:insert(i,-i)
        --PRINTF!("%d: %s\n", i, wbt1:treetostring())
        --PRINTF!("forest len %d i %d nodes %d marks %d\n", #forest, i, #forest.nodes, #forest.marks * 64)
        --PRINTF!("i %d wbt2 siz %d\n", i, #wbt2)
        wbt1, wbt2 = wbt2, wbt1
        expect.equal(#forest, 2)
        wbt2:destroy()
        expect.equal(#forest, 1)
        --PRINTF!("i %d wbt1 siz %d\n", i, #wbt1)
        expect.equal(#wbt1, i)
      end
      expect.equal(wbt1:get(42,-999), -42)
      expect.equal(wbt1:get(222,-999), -222)
      --PRINTF!("%s\n", wbt1:treetostring())
      --PRINTF!("gcwip size: %d\n", #forest.gcwip)
      --PRINTF!("240 inserts; sizes... nodes: %d marks %d gcwip: %d\n"
      --          , #forest.nodes, #forest.marks, #forest.gcwip)
      --for k,v in pairs(wbt1) do PRINTF!("k: %d v: %d\n", k, v) end
      --wbt1:destroy()
      --PRINTF!("forest %p <- %p -> %p\n", forest.roots.prev, &forest.roots, forest.roots.next)
      --forest:destroy()--== don't do this if <close> used above!
    end)


    -- A `wbtforest` using gc allocator cannot itself be stack allocated because
    -- it is referenced by wbtmapTs. When a `wbtforest` goes out of scope, the
    -- linked list of wbtrootTs point back at the now non-existant wbtrootT
    -- embedded in the `wbtforest` record. So, `new` must be used to allocate
    -- the `wbtforest`
    nester.it('grow autogc 1', function()
      -- debug
      -- collectgarbage()
      do
        local forest = gc_allocator:new(@wbtforest(integer, integer, nil, GCAllocator))
        local wbt1p = forest:makewbtmap()
        for i = 1, 240 do
          wbt1p = wbt1p:insert(i,-i) -- creates garbage
          -- debug: using this instead of the line above and without the `collectgarbage` above caused a crash... UGH TODO? FIXED?
          --local wbt2p = wbt1p:insert(i,-i)
          --wbt1p = wbt2p -- creates garbage
          --
          expect.equal(#wbt1p, i)
        end
        expect.equal(wbt1p:get(42,-999), -42)
        expect.equal(wbt1p:get(222,-999), -222)
        collectgarbage() -- make sure we go through a gc cycle to test:
        expect.equal(#forest, 1)
        --PRINTF!("forest %p <- %p -> %p\n", forest.roots.prev, &forest.roots, forest.roots.next)
        --PRINTF!("Forest size: %d\n", #forest)
      end
      collectgarbage() -- to trigger collection of forest and wbt1p
    end)

    nester.it('grow autogc 2', function()
      collectgarbage() -- to trigger collection of forest and wbt1p from above
    end)

    -- Here and in revpairs I "cheat" and stack allocate `forest`, but make
    -- sure to `destroy` all `wbtmapT`s
    nester.it('pairs', function()
      local forest: wbtforest(integer, integer)
      local wbt1 = forest:makewbtmap() -- : wbtmapT
      for k,v in pairs(wbt1) do
        expect.equal(k, v) -- to fail since there should be no pairs yet
      end
      for i = 1, 1000 do
        local wbt2 = wbt1:insert(i,-i)
        wbt1, wbt2 = wbt2, wbt1
        wbt2:destroy()
      end
      expect.equal(#wbt1, 1000)
      local i = 1
      for k,v in pairs(wbt1) do
        expect.equal(k, i)
        expect.equal(v, -i)
        i = i + 1
      end
      wbt1:destroy()
    end)

    nester.it('revpairs', function()
      local forest: wbtforest(integer, integer)
      local wbt1 = forest:makewbtmap() -- : wbtmapT
      for k,v in wbt1:revpairs() do
        expect.equal(k, v) -- to fail since there should be no pairs yet
      end
      for i = 1, 1000 do
        local wbt2 = wbt1:insert(i,-i)
        wbt1, wbt2 = wbt2, wbt1
        wbt2:destroy()
      end
      expect.equal(#wbt1, 1000)
      local i = 1000
      for k,v in wbt1:revpairs() do
        expect.equal(k, i)
        expect.equal(v, -i)
        i = i - 1
      end
      wbt1:destroy()
    end)

  end)
end)

nester.report() -- Print overall statistic of the tests run.
nester.exit() -- Exit with success if all tests passed.


  --[[
  assert(map:find_(0)==nilptr)
  local p: *integer = map:insert_(42)
  assert(p ~= nilptr)
  $p = -42
  p = map:find_(42)
  assert(p ~= nilptr)
  assert($p == -42)
  ##if WBTMAP_UNITTEST then
    assert(map:isbalanced())
    io.printf("Balanced!\n")
  ##end
  map:destroy()
  ]]

