--[[
The wbtforest library provides a generic implementation of
Weight Balanced Trees a.k.a. Bounded Balance Trees or BB[α] Trees
in a memory managed forest of trees of the same type.

References:

Implementing Sets Efficiently in a Functional Language
Stephen Adams
CSTR 92-10
Department of Electronics and Computer Science University of Southampton Southampton S09 5NH

Adams’ Trees Revisited Correct and Efficient Implementation
Milan Straka <fox@ucw.cz>
Department of Applied Mathematics Charles University in Prague, Czech Republic

Nelua implementation:

wbtforest provides a generic (parameterized) collection of key,value maps
using a persistent data structure; here persistent means that maps are never
modified, all operations return a new map that may share structure with other
maps in the same forest. When the space allocated to the forest is exhausted,
the space is automatically garbage collected (even when the Nelua program has
no garbage collector, -Pnogc), and may grow if it becomes too full. Nodes are
not scavenged until a tree root is destroyed by the caller of the library.

Features:

* Insert (``add``), lookup (``get``), and delete (``del``) in O(log(N)) time
* Key-ordered iterators (``inorder`` and ``revorder``)
* Lookup by relative position from beginning or end (``getNth``) in O(log(N)) time
* Get the position (``rank``) by key in O(log(N)) time
* Efficient set operations using tree keys
* ? Map extensions to set operations with optional value merge control for duplicates
]]

--[[
Copyright (c) 2012-2021 Doug Currie, Londonderry, NH, USA

Permission is hereby granted, free of charge, to any person obtaining a copy of this software
and associated documentation files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or
substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
]]

-- 2021-12-21 e

--[[
Design: wbtforest has span of tree nodes, a mark/free bitarray, a bump allocation index, and a
list of wbttree root records. All node "pointers" are indexes into the span of tree nodes.

The GC is non-moving; this allows wbt functions to hold node indexes into the node span across
GC calls, which may occur during allocations when space is exhausted within the function. A
separate compactor is provided that may be called at top level. The GC uses a bit span to hold
mark bits. This provides some cache locality for searching for free nodes during the sweep.
Option: eliminate the free list and use the mark bits alone?

The data structures are not protected with locks, and assume single threaded behavior; this is
consistent with other Nelua libraries.

To make this work with or without GC, we need to make the list (set? hashmap?) of tree roots
weak... but there are no weak tables yet!?

Discord: Does Nelua have any support or plan to support weak pointers in its GC? Searching the
documentation, source code, and Discord for "weak" brings no joy. ;-)  The library I'm
working on needs a "weak set" data structure to support use in both GC mode and no-GC mode.
Weakset could be implemented using a Lua table with a `{__mode = "k"}` metatable, but I'd be
really happy with a nelua weakset or weakhashmap, or even a weak doubly-linked-list. The only
operations I need are insert (`__atindex`), `remove`, and an iterator like `__pairs`.

Workaround: Keep the list of roots in the forest data structure, but return a wbt-token that
points to an entry in the list of roots. When the wbt-token is GC'd or `destroy`ed the `__gc`
metamethod deletes the entry from the list.

Nodes created during insert et al may have no gc root until the tree is stitched up, so we keep
a list `gcwip` of allocs for gc that is cleared before top level return from wbtreeT functions.
]]

--[[
I considered marking based on (Deutsch-)Schorr-Waite DFS, but since the algorithms use
recursion on trees, there is no big advantage to stackless marking relative to the stack
used by the primary algorithms. The stack depth is the same as the tree height, proportional
to the log base 2 of the tree size.
]]

require "edebug"
require "bitvector"

-- Constant used to enable unit test functions
## WBTFOREST_UNITTEST = true

local OMEGA: uint32 <comptime> = 3
local ALPHA: uint32 <comptime> = 2

-- Initial node capacity to reserve when inserting an element for the first time in wbt.
local INIT_CAPACITY: uint32 <comptime> = 64

-- Marker for nil nodes; to test we use node < bump; whereas (node ~= WBTNIL) is tempting,
-- it fails the "zero is initialization" precept; WBTNIL is always greater than bump
local WBTNIL: uint32 <comptime> = (@uint32)(-1)

-- Maximum load factor (used nodes per forest) in percent.
-- The container automatically increases the number of nodes if the load factor exceeds this threshold.
local MAX_LOAD_FACTOR: usize <comptime> = 85


## local function make_wbtforestT(K, V, CompareFunc, Allocator)
  ## static_assert(traits.is_type(K), "invalid type '%s'", K)
  ## static_assert(traits.is_type(V), "invalid type '%s'", V)
  ## if not Allocator then
  require 'allocators.default'
  ## Allocator = DefaultAllocator
  ## end
  -- https://discord.com/channels/680417078959800322/887388302938886144/922479556621897739
  ## if not CompareFunc then
    ## function CompareFunc(a, b)
      in #[a]# < #[b]# and -1 or (#[a]# > #[b]# and 1 or 0)
    ## end
  ## elseif CompareFunc.is_generic then
    ## CompareFunc = CompareFunc.func
  ## end

  local Allocator: type = #[Allocator]#
  local K: type = @#[K]#
  local V: type = @#[V]#

  -- wbt map node record defined when inserting into a `wbtmap`.
  local wbtnodeT: type <nickname(#[string.format('wbtmapnode(%s, %s)',K,V)]#)> = @record{
    lhs: uint32, -- index into span nodes
    rhs: uint32, -- index into span nodes
    siz: uint32,
    key: K,
    val: V
  }

  -- wbt map record defined when calling `wbtforest:make`.
  local wbtrootT: type <nickname(#[string.format('wbtroot(%s, %s)',K,V)]#)> = @record{
    prev: *wbtrootT, -- prev map in linked list of maps
    next: *wbtrootT, -- next map in linked list of maps
    node: uint32     -- index into span nodes, root of wbtree, WBTNIL for empty tree
  }

  -- wbt map record defined when instantiating the generic `wbtmap`.
  local wbtforestT: type <nickname(#[string.format('wbtforest(%s, %s)',K,V)]#)> = @record{
    roots: wbtrootT, -- sentinel in list of tree roots
    bumpa: uint32,   -- index into span nodes, bump allocator, full when bump == #nodes
    rover: uint32,   -- index into marks, the last free (unmarked) node allocated
    wip_n: uint32,   -- count of nodes in gcwip
    nodes: span(wbtnodeT),
    marks: span(uint64), -- mark bits
    gcwip: span(uint32), -- gc roots maybe not in tree yet
    allocator: Allocator
  }

  -- we make an indirect reference to the wbtrootT to support GC in lieu of weak sets
  -- wbt map record defined when calling `wbtforest:make`.
  local wbtmapT: type <nickname(#[string.format('wbtmap(%s, %s)',K,V)]#)> = @record{
    root: *wbtrootT,    -- indirection to tree root
    forest: *wbtforestT -- my forest
  }

  ##[[
  local wbtmapT = wbtmapT.value
  wbtmapT.is_container = true
  wbtmapT.K = K
  wbtmapT.V = V
  local wbtforestT = wbtforestT.value
  wbtforestT.is_container = true
  wbtforestT.K = K
  wbtforestT.V = V
  ]]

  -- internal function to initialize the forest wbtree roots list
  function wbtforestT:preprootslist(): void <inline>
    if unlikely(self.roots.prev == 0 or self.roots.next == 0) then
      -- make doubly linked list
      self.roots.prev = &self.roots
      self.roots.next = &self.roots
      self.roots.node = WBTNIL
    end
  end

  --[[
  Creates a wbt forest using a custom allocator instance.
  Useful only when using instanced allocators.

  e: this is copied from heapmap.nelua and I'm not sure it's useful

  function wbtforestT.make(allocator: Allocator): wbtforestT
    local m: wbtforestT
    m.allocator = allocator
    return m
  end
  ]]

  --[[
  Resets the container to a zeroed state, freeing all used resources.

  *Complexity*: O(1).
  ]]
  function wbtmapT:destroy(): void
    local iroot: *wbtrootT = self.root
    if iroot ~= WBTNIL then
      -- unlink from list
      iroot.prev.next = iroot.next
      iroot.next.prev = iroot.prev
      iroot.prev = nilptr
      iroot.next = nilptr
      iroot.node = WBTNIL
      self.forest.allocator:dealloc(iroot)
    end
  end

  -- Effectively the same as `destroy`, called when a to-be-closed variable goes out of scope.
  function wbtmapT:__close(): void
    self:destroy()
  end

  -- Effectively the same as `destroy`, called when record id garbage collected.
  function wbtmapT:__gc(): void
    self:destroy()
  end

  --[[
  Resets the container to a zeroed state, freeing all used resources.

  *Complexity*: O(1).
  ]]
  function wbtforestT:destroy(): void
    self.allocator:spandealloc(self.nodes)
    self.nodes = (@span(wbtnodeT))()
    self.bumpa = 0
    self.rover = 0
    -- We cannot delete the roots. It would leave dangling pointers for some wbtmapT records.
  end

  -- Effectively the same as `destroy`, called when a to-be-closed variable goes out of scope.
  function wbtforestT:__close(): void
    self:destroy()
  end

  -- Returns the number of elements in the container, in this case the number of roots.
  function wbtforestT:__len(): isize
    local size: isize = 0
    self:preprootslist()
    local rover: *wbtrootT = self.roots.next
    while rover ~= &self.roots do
      size = size + 1
      rover = rover.next
    end
    return size
  end

  -- internal function to try to get a free node using mark bits
  -- basically it's a piece of the sweep phase of the GC
  -- returns WBTNIL if there are no free nodes below self.bumpa
  function wbtforestT:firstfree(): uint32
    local node: uint32 = WBTNIL
    if self.rover < self.bumpa then
      -- try to get a free node
      node = bitvector.firstunmarked(self.marks, self.rover)
      self.rover = node -- ok if WBTNIL since it's > self.bumpa
      -- if return from firstunmarked is == bumpa, we transitioned to bump phase
      -- increment bumpa if so
      if node == self.bumpa then
        self.bumpa = node + 1
      end
    end
    return node
  end

  -- internal function to mark a subtree; returns count of new marks
  function wbtforestT:mark(node: uint32): uint32
    local used: uint32 = 0
    if node ~= WBTNIL and bitvector.setbit(self.marks, node) then
      --PRINTF!("Marking node %u key %d\n", node, self.nodes[node].key)
      used = 1_uint32
      used = used + self:mark(self.nodes[node].lhs)
      used = used + self:mark(self.nodes[node].rhs)
    end
    return used
  end

  -- internal function to mark all roots; returns count of marks
  function wbtforestT:markallroots(): uint32
    local used: uint32 = 0
    self:preprootslist()
    local rover: *wbtrootT = self.roots.next
    while rover ~= &self.roots do
      --PRINTF!("Marking root %u\n", rover.node)
      used = used + self:mark(rover.node)
      --PRINTF!("Marked %u found %u next %u\n", rover.node, used, rover.next.node)
      rover = rover.next
    end
    local wip_i: uint32 = 0
    while wip_i < self.wip_n do
      local node = self.gcwip[wip_i]
      --PRINTF!("Marking wip %u node %u\n", wip_i, node)
      used = used + self:mark(node)
      wip_i = wip_i + 1
    end
    return used
  end

  -- internal function to perform the mark phase of the GC setting the mark bits
  -- it may grow the nodes span if an insufficent number of nodes are free
  -- always returns a free node index
  function wbtforestT:markandalloc(): uint32
    local used: uint32 = 0
    if unlikely(#self.nodes == 0) then
      --PRINTF!("Initial Allocation %u\n", INIT_CAPACITY)
      -- need to allocate for the first time
      self.nodes = self.allocator:xspanalloc0(wbtnodeT, INIT_CAPACITY)
      self.marks = self.allocator:xspanalloc0(uint64, INIT_CAPACITY // 64_uint64)
      self.gcwip = self.allocator:xspanalloc0(uint32, INIT_CAPACITY)
    else
      bitvector.clearall(self.marks) -- zero the bitvector
      --PRINTF!("Marking begin\n")
      used = self:markallroots() -- GC mark phase
      --PRINTF!("Marking end\n")
      -- used/#nodes > 85/100 == 100 * used > 85 * #nodes
      -- note that using >= makes zero size forest pass the test
      if (100 * (@int64)(used)) >= (MAX_LOAD_FACTOR * #self.nodes) then
        --PRINTF!("Growing\n")
        -- need to grow
        local newsize: uint32 = #self.nodes * 2
        self.nodes = self.allocator:xspanrealloc0(self.nodes, newsize)
        self.marks = self.allocator:xspanrealloc0(self.marks, newsize // 64_uint64)
      end
    end
    self.rover = 0 -- new marks, start afresh
    -- now alloc node
    local node: uint32 = self:firstfree()
    if node == WBTNIL then
      if self.bumpa < #self.nodes then
        -- bump alloc
        node = self.bumpa
        self.bumpa = node + 1
      else
        --PRINTF!("Bumpa %u #nodes %d\n", self.bumpa, #self.nodes)
        assert(self.bumpa < #self.nodes) -- fail here; should not be possible
      end
    end
    return node
  end

  function wbtforestT:nodealloc(lhs: uint32, key: K, val: V, rhs: uint32, siz: uint32): uint32
    local node: uint32 = self:firstfree()
    if node == WBTNIL then
      if self.bumpa < #self.nodes then
        -- bump alloc
        node = self.bumpa
        self.bumpa = node + 1
      else
        assert(self.bumpa == #self.nodes)
        node = self:markandalloc()
      end
    end
    self.nodes[node].lhs = lhs
    self.nodes[node].rhs = rhs
    self.nodes[node].siz = siz
    self.nodes[node].key = key
    self.nodes[node].val = val
    -- add node to gcwip
    if self.wip_n >= #self.gcwip then
      -- grow gcwip
      self.gcwip = self.allocator:xspanrealloc(self.gcwip, 2 * #self.gcwip)
    end
    self.gcwip[self.wip_n] = node
    self.wip_n = self.wip_n + 1
    return node
  end

  function wbtforestT:nodesize(node: uint32): uint32 <inline>
    if node < self.bumpa then
      return self.nodes[node].siz
    else
      return 0
    end
  end

  function wbtforestT:newleaf(key: K, val: V): uint32 <inline>
    -- constructor for a leaf node
    return self:nodealloc(WBTNIL, key, val, WBTNIL, 1)
  end

  function wbtforestT:newnode(lhs: uint32, key: K, val: V, rhs: uint32): uint32 <inline>
    -- constructor for a new node
    local size = self:nodesize(lhs) + 1 + self:nodesize(rhs)
    return self:nodealloc(lhs, key, val, rhs, size)
  end

  function wbtforestT:singleL(lhs: uint32, key: K, val: V, rhs: uint32): uint32
    return self:newnode(
      self:newnode(lhs, key, val, self.nodes[rhs].lhs),
      self.nodes[rhs].key,
      self.nodes[rhs].val,
      self.nodes[rhs].rhs)
  end
  function wbtforestT:singleR(lhs: uint32, key: K, val: V, rhs: uint32): uint32
    return self:newnode(
      self.nodes[lhs].lhs,
      self.nodes[lhs].key,
      self.nodes[lhs].val,
      self:newnode(self.nodes[lhs].rhs, key, val, rhs))
  end
  function wbtforestT:doubleL(lhs: uint32, key: K, val: V, rhs: uint32): uint32
    local rl = self.nodes[rhs].lhs
    return self:newnode(
      self:newnode(lhs, key, val, self.nodes[rl].lhs),
      self.nodes[rl].key,
      self.nodes[rl].val,
      self:newnode(
        self.nodes[rl].rhs,
        self.nodes[rhs].key,
        self.nodes[rhs].val,
        self.nodes[rhs].rhs))
  end
  function wbtforestT:doubleR(lhs: uint32, key: K, val: V, rhs: uint32): uint32
    local lr = self.nodes[lhs].rhs
    return self:newnode(
      self:newnode(
        self.nodes[lhs].lhs,
        self.nodes[lhs].key,
        self.nodes[lhs].val,
        self.nodes[lr].lhs),
      self.nodes[lr].key,
      self.nodes[lr].val,
      self:newnode(self.nodes[lr].rhs, key, val, rhs))
  end

  function wbtforestT:balance(lhs: uint32, key: K, val: V, rhs: uint32): uint32
    local result = WBTNIL
    local sl = self:nodesize(lhs)
    local sr = self:nodesize(rhs)
    if ((sl + sr) <= 1) then
        result = self:newnode(lhs, key, val, rhs)
    elseif (sr > (OMEGA * sl)) then
        if (self:nodesize(self.nodes[rhs].lhs) < (ALPHA * self:nodesize(self.nodes[rhs].rhs))) then
            result = self:singleL(lhs, key, val, rhs)
        else
            result = self:doubleL(lhs, key, val, rhs)
        end
    elseif (sl > (OMEGA * sr)) then
        if (self:nodesize(self.nodes[lhs].rhs) < (ALPHA * self:nodesize(self.nodes[lhs].lhs))) then
            result = self:singleR(lhs, key, val, rhs)
        else
            result = self:doubleR(lhs, key, val, rhs)
        end
    else
        result = self:newnode(lhs, key, val, rhs)
    end
    return result
  end

  function wbtforestT:insert(n: uint32, k: K, v: V): uint32
    if n == WBTNIL then
      return self:newleaf(k, v)
    end
    local root = self.nodes[n]
    local dif = #[CompareFunc]#(k, root.key)
    switch dif
    case -1 then
      return self:balance(self:insert(root.lhs, k, v), root.key, root.val, root.rhs)
    case  1 then
      return self:balance(root.lhs, root.key, root.val, self:insert(root.rhs, k, v))
    else
      -- XXX: check if val equal to avoid alloc? not possible without second compare func
      return self:newnode(root.lhs, k, v, root.rhs)
    end
  end

  -- default is returned is key is not in tree
  function wbtforestT:getordefault(root: uint32, key: K, default: V): V
    -- Retrieves the value for `key` in the tree `root` iff `key` is in the tree.
    -- Otherwise, `default` is returned. O(log N)
    local result = default
    local node = root
    while node ~= WBTNIL do
        local dif = #[CompareFunc]#(key, self.nodes[node].key)
        switch dif
        case -1 then
          node = self.nodes[node].lhs
        case  1 then
          node = self.nodes[node].rhs
        else -- key and self.nodes[node].key are eq
          result = self.nodes[node].val
          node = WBTNIL -- break
        end
    end
    return result
  end

  function wbtforestT:makewbtmap_(node: uint32): wbtmapT
    local wbt: wbtmapT
    local rootp: *wbtrootT = (@*wbtrootT)(self.allocator:xalloc0(#wbtrootT))
    rootp.node = node
    -- insert wbtroot into doubly linked list
    self:preprootslist()
    rootp.next = self.roots.next
    self.roots.next = rootp
    rootp.prev = &self.roots
    rootp.next.prev = rootp
    -- fill out result
    wbt.forest = self
    wbt.root = rootp
    return wbt
  end

  function wbtforestT:makewbtmap(): wbtmapT
    return self:makewbtmap_(WBTNIL)
  end

  function wbtforestT:wbtsize(node: uint32)
    if node < self.bumpa then
      return self.nodes[node].siz
    else
      return 0
    end
  end

  function wbtmapT:insert(k: K, v: V): wbtmapT
    local node: uint32 = self.forest:insert(self.root.node, k, v)
    self.forest.wip_n = 0 -- no more wip
    return self.forest:makewbtmap_(node)
  end

  function wbtmapT:getordefault(k: K, default: V): V
    return self.forest:getordefault(self.root.node, k, default)
  end

  function wbtmapT:__len(): isize
    return self.forest:wbtsize(self.root.node)
  end

  -- wbtree iterator
  local wbtmap_iteratorT: type = @record{
    forest: *wbtforestT,
    stack: span(uint32),
    stidx: uint32,
    next: uint32
  }

  --[[
  Advances the wbtmapT container iterator returning its key and value.

  *Remarks*: The input `key` is actually ignored.
  ]]
  function wbtmap_iteratorT:next(key: K): (boolean, K, V)
    local curr = self.next
    if unlikely(self.stidx == WBTNIL) then
      -- init the stack; curr is root
      self.stidx = 0
    elseif curr ~= WBTNIL then
      -- go right from last yielded node
      curr = self.forest.nodes[curr].rhs
    end
    if curr ~= WBTNIL or self.stidx > 0 then
      while curr ~= WBTNIL do -- push node before going left
        if unlikely(self.stidx >= #self.stack) then
          self.stack = self.forest.allocator:xspanrealloc(self.stack, 2 * #self.stack)
        end
        self.stack[self.stidx] = curr
        self.stidx = self.stidx + 1
        curr = self.forest.nodes[curr].lhs
      end
      -- at the leftmost node; curr is nil; pop
      self.stidx = self.stidx - 1
      curr = self.stack[self.stidx]
      self.next = curr
      return true, self.forest.nodes[curr].key, self.forest.nodes[curr].val
    else
      -- it is an empty tree or we're at the end
      -- dealloc stack
      self.forest.allocator:spandealloc(self.stack)
      self.stack = (@span(uint32))()
      return false, (@K)(), (@V)()
    end
  end

  function wbtmap_iteratorT:revnext(key: K): (boolean, K, V)
    local curr = self.next
    if unlikely(self.stidx == WBTNIL) then
      -- init the stack; curr is root
      self.stidx = 0
    elseif curr ~= WBTNIL then
      -- go left from last yielded node
      curr = self.forest.nodes[curr].lhs
    end
    if curr ~= WBTNIL or self.stidx > 0 then
      while curr ~= WBTNIL do -- push node before going right
        if unlikely(self.stidx >= #self.stack) then
          self.stack = self.forest.allocator:xspanrealloc(self.stack, 2 * #self.stack)
        end
        self.stack[self.stidx] = curr
        self.stidx = self.stidx + 1
        curr = self.forest.nodes[curr].rhs
      end
      -- at the righttmost node; curr is nil; pop
      self.stidx = self.stidx - 1
      curr = self.stack[self.stidx]
      self.next = curr
      return true, self.forest.nodes[curr].key, self.forest.nodes[curr].val
    else
      -- it is an empty tree or we're at the end
      -- dealloc stack
      self.forest.allocator:spandealloc(self.stack)
      self.stack = (@span(uint32))()
      return false, (@K)(), (@V)()
    end
  end

  -- Support using `pairs()` to iterate the wbtmapT container.
  function wbtmapT:__pairs(): (auto, wbtmap_iteratorT, K) <inline>
    return wbtmap_iteratorT.next,
           (@wbtmap_iteratorT){forest = self.forest,
                               stack = self.forest.allocator:xspanalloc(uint32, INIT_CAPACITY),
                               stidx = WBTNIL,
                               next = self.root.node},
           (@K)()
  end

  -- Support using `revpairs()` to iterate the wbtmapT container.
  function wbtmapT:revpairs(): (auto, wbtmap_iteratorT, K) <inline>
    return wbtmap_iteratorT.revnext,
           (@wbtmap_iteratorT){forest = self.forest,
                               stack = self.forest.allocator:xspanalloc(uint32, INIT_CAPACITY),
                               stidx = WBTNIL,
                               next = self.root.node},
           (@K)()
  end

## if WBTFOREST_UNITTEST then
  function wbtforestT:treetostring(n: uint32): string
    -- assume int keys
    if n == WBTNIL then
      return ""
    end
    local root = self.nodes[n]
    return string.format("(%s %d %s)",
             self:treetostring(root.lhs), root.key, self:treetostring(root.rhs))
  end
  function wbtmapT:treetostring(): string
    return self.forest:treetostring(self.root.node)
  end
## end


  -- TODO

--  function wbtmapT:balanced_(node: uint32): isize
--    if node == WBTNIL then return 0 end
--    local sl: uint32 = self:nodesize_(self.nodes[node].l)
--    local sr: uint32 = self:nodesize_(self.nodes[node].r)
--    local sz: uint32 = self:nodesize_(node)
--    if (sl + 1 + sr) ~= sz then
--      io.printf("Error in wbtmap balanced: %u != %u + 1 + %u; (%u %u)\n", sz, sl, sr, self.nodes[node].l, self.nodes[node].r)
--      return -1
--    end
--    if (sl + sr) <= 1 then
--      -- balanced
--    elseif sr > (OMEGA * sl) then
--      io.printf("Error in wbtmap balanced: sr %u > omega * %u\n", sr, sl)
--      return -1
--    elseif sl > (OMEGA * sr) then
--      io.printf("Error in wbtmap balanced: sl %u > omega * %u\n", sl, sr)
--      return -1
--    end
--    local slb: isize = self:balanced_(self.nodes[node].l)
--    local srb: isize = self:balanced_(self.nodes[node].r)
--    if (slb < 0) or (sl ~= slb) then
--      if (slb >= 0) then io.printf("Error in wbtmap balanced: sl %u != %lld\n", sl, slb) end
--      return -1
--    end
--    if (srb < 0) or (sr ~= srb) then
--      if (srb >= 0) then io.printf("Error in wbtmap balanced:  sr %u != %lld\n", sr, srb) end
--      return -1
--    end
--    return sz
--  end
--
--  -- Unit test function returns `true` if the tree is balanced which should always be true
--  function wbtmapT:isbalanced(): boolean
--    local sz: isize = self:balanced_(self.root)
--    if self.root < self.bump then
--      return (sz > 0) and (sz == self:nodesize_(self.root))
--    else
--      return (sz == 0)
--    end
--  end
--
--  ##end

  ## return wbtforestT
## end

--[[
Generic used to instantiate a wbt map type in the form of `wbtforest(K, V, CompareFunc, Allocator)`.

Argument `K` is the key type for the wbt maps within the forest.
Argument `V` is the value type for the wbt maps within the forest.
Argument `CompareFunc` is a function to compare two keys in the sense of __lt,
in case absent then `__lt` is used.
Argument `Allocator` is an allocator type for the container storage,
in case absent then then `DefaultAllocator` is used.
]]
global wbtforest: type = #[generalize(make_wbtforestT)]#

return wbtforest


