--[[
The wbtforest library provides a generic implementation of
Weight Balanced Trees a.k.a. Bounded Balance Trees or BB[α] Trees
in a memory managed forest of trees of the same type.

References:

Implementing Sets Efficiently in a Functional Language
Stephen Adams
CSTR 92-10
Department of Electronics and Computer Science University of Southampton Southampton S09 5NH

Adams’ Trees Revisited Correct and Efficient Implementation
Milan Straka <fox@ucw.cz>
Department of Applied Mathematics Charles University in Prague, Czech Republic

Nelua implementation:

wbtforest provides a generic (parameterized) collection of key,value maps
using a persistent data structure; here persistent means that maps are never
modified, all operations return a new map that may share structure with other
maps in the same forest. When the space allocated to the forest is exhausted,
the space is automatically garbage collected (even when the Nelua program has
no garbage collector, -Pnogc), and may grow if it becomes too full. Nodes are
not scavenged until a tree root is destroyed by the caller of the library.

Features:

* Insert (``add``), lookup (``get``), and delete (``del``) in O(log(N)) time
* Key-ordered iterators (``inorder`` and ``revorder``)
* Lookup by relative position from beginning or end (``getNth``) in O(log(N)) time
* Get the position (``getrank``) by key in O(log(N)) time
* Efficient set operations using tree keys
* ? Map extensions to set operations with optional value merge control for duplicates
]]

--[[
Copyright (c) 2012-2021 Doug Currie, Londonderry, NH, USA

Permission is hereby granted, free of charge, to any person obtaining a copy of this software
and associated documentation files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or
substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
]]

require "edebug"
require "bitvector"

-- Constant used to enable unit test functions
## WBTFOREST_UNITTEST = true

local OMEGA: uint32 <comptime> = 3
local ALPHA: uint32 <comptime> = 2

-- Initial node capacity to reserve when inserting an element for the first time in wbt.
local INIT_CAPACITY: uint32 <comptime> = 64

-- Marker for nil nodes; to test we use node < bump; whereas (node ~= WBTNIL) is tempting,
-- it fails the "zero is initialization" precept; WBTNIL is always greater than bump
local WBTNIL: uint32 <comptime> = (@uint32)(-1)

-- Maximum load factor (used nodes per forest) in percent.
-- The container automatically increases the number of nodes if the load factor exceeds this threshold.
local MAX_LOAD_FACTOR: usize <comptime> = 85


## local function make_wbtforestT(K, V, CompareFunc, Allocator)
  ## static_assert(traits.is_type(K), "invalid type '%s'", K)
  ## static_assert(traits.is_type(V), "invalid type '%s'", V)
  ## if not Allocator then
  require 'allocators.default'
  ## Allocator = DefaultAllocator
  ## end
  -- https://discord.com/channels/680417078959800322/887388302938886144/922479556621897739
  ## if not CompareFunc then
    ## function CompareFunc(a, b)
      in #[a]# < #[b]# and -1 or (#[a]# > #[b]# and 1 or 0)
    ## end
  ## elseif CompareFunc.is_generic then
    ## CompareFunc = CompareFunc.func
  ## end

  local Allocator: type = #[Allocator]#
  local K: type = @#[K]#
  local V: type = @#[V]#

  -- wbt map node record defined when inserting into a `wbtmap`.
  local wbtnodeT: type <nickname(#[string.format('wbtmapnode(%s, %s)',K,V)]#)> = @record{
    lhs: uint32, -- index into span nodes
    rhs: uint32, -- index into span nodes
    siz: uint32,
    key: K,
    val: V
  }

  -- wbt map record defined when calling `wbtforest:make`.
  local wbtrootT: type <nickname(#[string.format('wbtroot(%s, %s)',K,V)]#)> = @record{
    prev: *wbtrootT, -- prev map in linked list of maps
    next: *wbtrootT, -- next map in linked list of maps
    node: uint32     -- index into span nodes, root of wbtree, WBTNIL for empty tree
  }

  local wbttrailT <forwarddecl> =  @record{} -- circular references between wbttrailT and wbtforestT

  -- wbt map record defined when instantiating the generic `wbtmap`.
  local wbtforestT: type <nickname(#[string.format('wbtforest(%s, %s)',K,V)]#)> = @record{
    roots: wbtrootT, -- sentinel in list of tree roots
    rover: uint32,   -- index into marks, the last free (unmarked) node allocated
    wip_n: uint32,   -- count of nodes in gcwip
    nodes: span(wbtnodeT),
    marks: span(uint64), -- mark bits
    gcwip: span(uint32), -- gc roots maybe not in tree yet
    trail: *wbttrailT,
    allocator: Allocator
  }

  -- we make an indirect reference to the wbtforestT to support disposing of the wbtforestT
  -- possible while wbtmapT instances are still live
  wbttrailT = @record{
    forest: *wbtforestT, -- my forest
    allocator: Allocator -- the allocator used to make the wbtmapT and wbttrailT instances
  }

  -- we make an indirect reference to the wbtrootT to support GC in lieu of weak sets
  -- wbt map record defined when calling `wbtforest:make`.
  local wbtmapT: type <nickname(#[string.format('wbtmap(%s, %s)',K,V)]#)> = @record{
    root: *wbtrootT,  -- indirection to tree root
    trail: *wbttrailT -- the trail to my forest
  }

  ##[[
  local wbtmapT = wbtmapT.value
  wbtmapT.is_container = true
  wbtmapT.K = K
  wbtmapT.V = V
  local wbtforestT = wbtforestT.value
  wbtforestT.is_container = true
  wbtforestT.K = K
  wbtforestT.V = V
  ]]

  -- internal function to initialize the forest wbtree roots list
  function wbtforestT:preprootslist(): void <inline>
    if unlikely(self.roots.prev == 0) then
      -- make doubly linked list
      self.roots.prev = &self.roots
      self.roots.next = &self.roots
      self.roots.node = WBTNIL
      -- make trail
      assert(self.trail == nilptr)
      --self.trail = (@*wbttrailT)(self.allocator:xalloc0(#wbttrailT)) -- didn't typecheck
      self.trail = self.allocator:new(@wbttrailT)
      self.trail.forest = self
      self.trail.allocator = self.allocator -- needed for destroy calls when forest gone
    end
  end

  --[[
  Creates a wbt forest using a custom allocator instance.
  Useful only when using instanced allocators.

  e: this is copied from heapmap.nelua and I'm not sure it's useful

  function wbtforestT.make(allocator: Allocator): wbtforestT
    local m: wbtforestT
    m.allocator = allocator
    return m
  end
  ]]

  --[[
  Resets the container to a zeroed state, freeing all used resources.

  *Complexity*: O(1).
  ]]
  function wbtmapT:destroy(): void
    local iroot: *wbtrootT = self.root
    local allocator = self.trail.allocator
    if iroot ~= nilptr then
      -- make idempotent
      self.root = nilptr
      -- check to see if the list has only one item
      if iroot.next == iroot then
        -- the list is now empty and the wbttrail can be destroyed
        allocator:dealloc(self.trail)
        --PRINTF!('Destroying trail from wbtmap\n')
      else
        --PRINTF!('Unlink %p <- %p -> %p\n', iroot.prev, iroot, iroot.next)
        -- unlink from list
        iroot.prev.next = iroot.next
        iroot.next.prev = iroot.prev
      end
      iroot.prev = nilptr
      iroot.next = nilptr
      iroot.node = WBTNIL
      allocator:dealloc(iroot)
    end
  end

  -- Effectively the same as `destroy`, called when a to-be-closed variable goes out of scope.
  function wbtmapT:__close(): void
    --PRINTF!("__close %u %p <- %p -> %p\n", self.root.node, self.root.prev, self.root, self.root.next)
    self:destroy()
  end

  -- Effectively the same as `destroy`, called when record id garbage collected.
  function wbtmapT:__gc(): void
    --PRINTF!("__gc %u\n", self.root.node)
    self:destroy()
  end

  --[[
  Resets the container to a zeroed state, freeing all used resources.

  *Complexity*: O(1).
  ]]
  function wbtforestT:destroy(): void
    self.allocator:spandealloc(self.nodes)
    self.nodes = (@span(wbtnodeT))()
    self.rover = 0
    if self.trail ~= nilptr then
      self.trail.forest = nilptr -- delink this forest from its trail leaving trail in place
    end
    -- We cannot delete the roots. It would leave dangling pointers for some wbtmapT records.
    -- Check to see if the list of roots is uninitialized or has only one item, the sentinel
    if self.roots.next == 0 or self.roots.next == &self.roots then
      -- the list is empty and the wbttrail can be destroyed
      if self.trail ~= nilptr then
        self.allocator:dealloc(self.trail)
      end
      --PRINTF!('Destroying trail from wbtforest\n')
    else
      -- remove the forest from the list of roots
      self.roots.prev.next = self.roots.next
      self.roots.next.prev = self.roots.prev
      self.roots.next = nilptr
      self.roots.prev = nilptr
      --PRINTF!('NOT destroying trail from wbtforest\n')
    end
  end

  -- Effectively the same as `destroy`, called when a to-be-closed variable goes out of scope.
  function wbtforestT:__close(): void
    self:destroy()
  end

  -- Effectively the same as `destroy`, called when record id garbage collected.
  function wbtforestT:__gc(): void
    self:destroy()
  end

  -- Returns the number of elements in the container, in this case the number of roots.
  function wbtforestT:__len(): isize
    local size: isize = 0
    self:preprootslist()
    local rover: *wbtrootT = self.roots.next
    while rover ~= &self.roots do
      size = size + 1
      rover = rover.next
    end
    return size
  end

  --[[ ************************ gc ************************ ]]

  -- internal function to try to get a free node using mark bits
  -- basically it's a piece of the sweep phase of the GC
  -- returns WBTNIL if there are no free nodes
  function wbtforestT:firstfree(): uint32
    local node: uint32 = WBTNIL
    if self.rover < #self.nodes then
      -- try to get a free node
      node = bitvector.firstunmarked(self.marks, self.rover)
      self.rover = node -- ok if WBTNIL since it's > #self.nodes
    end
    return node
  end

  -- internal function to mark a subtree; returns count of new marks
  function wbtforestT:mark(node: uint32): uint32
    local used: uint32 = 0
    if node ~= WBTNIL and bitvector.setbit(self.marks, node) then
      --PRINTF!("Marking node %u key %d\n", node, self.nodes[node].key)
      used = 1_uint32
      used = used + self:mark(self.nodes[node].lhs)
      used = used + self:mark(self.nodes[node].rhs)
    end
    return used
  end

  -- internal function to mark all roots; returns count of marks
  function wbtforestT:markallroots(): uint32
    local used: uint32 = 0
    self:preprootslist()
    local rover: *wbtrootT = self.roots.next
    while rover ~= &self.roots do
      --PRINTF!("Marking root %u\n", rover.node)
      used = used + self:mark(rover.node)
      --PRINTF!("Marked %u found %u next %u\n", rover.node, used, rover.next.node)
      rover = rover.next
    end
    local wip_i: uint32 = 0
    while wip_i < self.wip_n do
      local node = self.gcwip[wip_i]
      --PRINTF!("Marking wip %u node %u\n", wip_i, node)
      used = used + self:mark(node)
      wip_i = wip_i + 1
    end
    return used
  end

  -- internal function to perform the mark phase of the GC setting the mark bits
  -- it may grow the nodes span if an insufficent number of nodes are free
  -- always returns a free node index
  function wbtforestT:markandalloc(): uint32
    local used: uint32 = 0
    if unlikely(#self.nodes == 0) then
      --PRINTF!("Initial Allocation %u\n", INIT_CAPACITY)
      -- need to allocate for the first time
      self.nodes = self.allocator:xspanalloc(wbtnodeT, INIT_CAPACITY)
      self.marks = self.allocator:xspanalloc0(uint64, INIT_CAPACITY // 64_uint64)
      self.gcwip = self.allocator:xspanalloc(uint32, INIT_CAPACITY)
    else
      bitvector.clearall(self.marks) -- zero the bitvector
      --PRINTF!("Marking begin\n")
      used = self:markallroots() -- GC mark phase
      --PRINTF!("Marking end\n")
      -- used/#nodes > 85/100 == 100 * used > 85 * #nodes
      -- note that using >= makes zero size forest pass the test
      if (100 * (@int64)(used)) >= (MAX_LOAD_FACTOR * #self.nodes) then
        --PRINTF!("Growing\n")
        -- need to grow
        local newsize: uint32 = #self.nodes * 2
        self.nodes = self.allocator:xspanrealloc(self.nodes, newsize)
        self.marks = self.allocator:xspanrealloc0(self.marks, newsize // 64_uint64)
      end
    end
    self.rover = 0 -- new marks, start afresh
    -- now alloc node
    local node: uint32 = self:firstfree()
    if node == WBTNIL then
      assert(node < #self.nodes) -- fail here; should not be possible
    end
    return node
  end

  --[[ ************************ node alloc ************************ ]]

  function wbtforestT:nodealloc(lhs: uint32, key: K, val: V, rhs: uint32, siz: uint32): uint32
    local node: uint32 = self:firstfree()
    if node == WBTNIL then
      node = self:markandalloc()
    end
    self.nodes[node].lhs = lhs
    self.nodes[node].rhs = rhs
    self.nodes[node].siz = siz
    self.nodes[node].key = key
    self.nodes[node].val = val
    -- add node to gcwip
    if self.wip_n >= #self.gcwip then
      -- grow gcwip
      self.gcwip = self.allocator:xspanrealloc(self.gcwip, 2 * #self.gcwip)
    end
    self.gcwip[self.wip_n] = node
    self.wip_n = self.wip_n + 1
    return node
  end

  function wbtforestT:nodesize(node: uint32): uint32 <inline>
    if node < #self.nodes then
      return self.nodes[node].siz
    else
      return 0
    end
  end

  function wbtforestT:newleaf(key: K, val: V): uint32 <inline>
    -- constructor for a leaf node
    return self:nodealloc(WBTNIL, key, val, WBTNIL, 1)
  end

  function wbtforestT:newnode(lhs: uint32, key: K, val: V, rhs: uint32): uint32 <inline>
    -- constructor for a new node
    local size = self:nodesize(lhs) + 1 + self:nodesize(rhs)
    return self:nodealloc(lhs, key, val, rhs, size)
  end

  --[[ ************************ balance ************************ ]]

  function wbtforestT:singleL(lhs: uint32, key: K, val: V, rhs: uint32): uint32
    return self:newnode(
      self:newnode(lhs, key, val, self.nodes[rhs].lhs),
      self.nodes[rhs].key,
      self.nodes[rhs].val,
      self.nodes[rhs].rhs)
  end
  function wbtforestT:singleR(lhs: uint32, key: K, val: V, rhs: uint32): uint32
    return self:newnode(
      self.nodes[lhs].lhs,
      self.nodes[lhs].key,
      self.nodes[lhs].val,
      self:newnode(self.nodes[lhs].rhs, key, val, rhs))
  end
  function wbtforestT:doubleL(lhs: uint32, key: K, val: V, rhs: uint32): uint32
    local rl = self.nodes[rhs].lhs
    return self:newnode(
      self:newnode(lhs, key, val, self.nodes[rl].lhs),
      self.nodes[rl].key,
      self.nodes[rl].val,
      self:newnode(
        self.nodes[rl].rhs,
        self.nodes[rhs].key,
        self.nodes[rhs].val,
        self.nodes[rhs].rhs))
  end
  function wbtforestT:doubleR(lhs: uint32, key: K, val: V, rhs: uint32): uint32
    local lr = self.nodes[lhs].rhs
    return self:newnode(
      self:newnode(
        self.nodes[lhs].lhs,
        self.nodes[lhs].key,
        self.nodes[lhs].val,
        self.nodes[lr].lhs),
      self.nodes[lr].key,
      self.nodes[lr].val,
      self:newnode(self.nodes[lr].rhs, key, val, rhs))
  end

  function wbtforestT:balance(lhs: uint32, key: K, val: V, rhs: uint32): uint32
    local result = WBTNIL
    local sl = self:nodesize(lhs)
    local sr = self:nodesize(rhs)
    if ((sl + sr) <= 1) then
        result = self:newnode(lhs, key, val, rhs)
    elseif (sr > (OMEGA * sl)) then
        if (self:nodesize(self.nodes[rhs].lhs) < (ALPHA * self:nodesize(self.nodes[rhs].rhs))) then
            result = self:singleL(lhs, key, val, rhs)
        else
            result = self:doubleL(lhs, key, val, rhs)
        end
    elseif (sl > (OMEGA * sr)) then
        if (self:nodesize(self.nodes[lhs].rhs) < (ALPHA * self:nodesize(self.nodes[lhs].lhs))) then
            result = self:singleR(lhs, key, val, rhs)
        else
            result = self:doubleR(lhs, key, val, rhs)
        end
    else
        result = self:newnode(lhs, key, val, rhs)
    end
    return result
  end

  --[[ ************************ insert ************************ ]]

  function wbtforestT:insert(n: uint32, k: K, v: V): uint32
    if n >= #self.nodes --[[ == WBTNIL ]] then
      return self:newleaf(k, v)
    end
    local root = self.nodes[n]
    local dif = #[CompareFunc]#(k, root.key)
    switch dif
    case -1 then
      return self:balance(self:insert(root.lhs, k, v), root.key, root.val, root.rhs)
    case  1 then
      return self:balance(root.lhs, root.key, root.val, self:insert(root.rhs, k, v))
    else
      -- XXX: check if val equal to avoid alloc? not possible without second compare func
      return self:newnode(root.lhs, k, v, root.rhs)
    end
  end

  --[[ ************************ lookup ************************ ]]

  -- default is returned is key is not in tree
  function wbtforestT:get(root: uint32, key: K, default: V): V
    -- Retrieves the value for `key` in the tree `root` iff `key` is in the tree.
    -- Otherwise, `default` is returned. O(log N)
    local result = default
    local node = root
    while node ~= WBTNIL do
        local dif = #[CompareFunc]#(key, self.nodes[node].key)
        switch dif
        case -1 then
          node = self.nodes[node].lhs
        case  1 then
          node = self.nodes[node].rhs
        else -- key and self.nodes[node].key are eq
          result = self.nodes[node].val
          node = WBTNIL -- break
        end
    end
    return result
  end

  --[[ ************************ delete ************************ ]]

  function wbtforestT:extractMin(node: uint32): (K, V, uint32) -- mink, minv, node'
    if self.nodes[node].lhs == WBTNIL then
        return self.nodes[node].key, self.nodes[node].val, self.nodes[node].rhs
    else
        local mink, minv, nodep = self:extractMin(self.nodes[node].lhs)
        return mink, minv, self:balance(nodep, self.nodes[node].key, self.nodes[node].val, self.nodes[node].rhs)
    end
  end

  function wbtforestT:extractMax(node: uint32): (K, V, uint32) -- maxk, maxv, node'
    if self.nodes[node].rhs == WBTNIL then
        return self.nodes[node].key, self.nodes[node].val, self.nodes[node].lhs
    else
        local maxk, maxv, nodep = self:extractMax(self.nodes[node].rhs)
        return maxk, maxv, self:balance(self.nodes[node].lhs, self.nodes[node].key, self.nodes[node].val, nodep)
    end
  end

  function wbtforestT:glue(lhs: uint32, rhs: uint32): uint32
    local result: uint32 = WBTNIL
    if lhs == WBTNIL then
        result = rhs
    elseif rhs == WBTNIL then
        result = lhs
    elseif self:nodesize(lhs) > self:nodesize(rhs) then
        local maxk, maxv, lhsp = self:extractMax(lhs)
        result = self:newnode(lhsp, maxk, maxv, rhs)
    else
        local mink, minv, rhsp = self:extractMin(rhs)
        result = self:newnode(lhs, mink, minv, rhsp)
    end
    return result
  end

  function wbtforestT:delete(root: uint32, key: K): uint32
    -- Deletes `key` from tree `root`. Does nothing if the key does not exist.
    -- O(log N)
    local result = WBTNIL
    if root == WBTNIL then
        result = root
    else
      local dif = #[CompareFunc]#(key, self.nodes[root].key)
      switch dif
      case -1 then
        result = self:balance(self:delete(self.nodes[root].lhs, key), self.nodes[root].key, self.nodes[root].val, self.nodes[root].rhs)
      case 1 then
        result = self:balance(self.nodes[root].lhs, self.nodes[root].key, self.nodes[root].val, self:delete(self.nodes[root].rhs, key))
      else -- key and self.nodes[root].key are eq
        result = self:glue(self.nodes[root].lhs, self.nodes[root].rhs)
      end
    end
    return result
  end

  function wbtforestT:delmin(root: uint32): uint32
    -- Delete the minimum element from tree `root`. O(log N)
    local result = WBTNIL
    if root == WBTNIL then
        result = root
    else
        local mink, minv, node = self:extractMin(root)
        result = node
    end
    return result
  end

  function wbtforestT:delmax(root: uint32): uint32
    -- Delete the maximum element from tree `root`. O(log N)
    local result = WBTNIL
    if root == WBTNIL then
        result = root
    else
        local maxk, maxv, node = self:extractMax(root)
        result = node
    end
    return result
  end

  --[[ ************************ ranked lookup ************************ ]]

  function wbtforestT:getNth(root: uint32, index: integer, kdefault: K, vdefault: V): (K, V)
    -- Get the key,value pair of the 0-based `index` key in the tree `root` when index is
    -- positive and less than the tree length. Or get the tree length plus `index` key in
    -- the tree `root` when the `index` is negative and greater than the negative tree length.
    -- Otherwise, `kdefault, vdefault` is returned. O(log N)
    local treesize: integer = self:nodesize(root) -- convert from uint32 for signed op
    local uindex: uint32 = 0
    local node: uint32 = root
    if (index < treesize) and (index >= (-treesize)) then
      if index < 0 then
          uindex = (@uint32)(treesize + index) -- when negative, reverse index from end rather than inorder
      else
          uindex = (@uint32)(index) -- all set
      end
      while node ~= WBTNIL do
        local lhssize = self:nodesize(self.nodes[node].lhs)
        if uindex < lhssize then
          node = self.nodes[node].lhs
        elseif uindex > lhssize then
          uindex = uindex - (lhssize + 1)
          node = self.nodes[node].rhs
        else -- we are there!
          return self.nodes[node].key, self.nodes[node].val
        end
      end
    end
    -- else index is out of range; default is returned
    return kdefault, vdefault
  end

  function wbtforestT:getmin(root: uint32, kdefault: K, vdefault: V): (K, V)
    -- Retrieves the key,value pair with the smallest key in the tree `root`
    -- For an empty tree `default` is returned. O(log N)
    local node = root
    if node > #self.nodes then -- or node == WBTNIL then
      return kdefault, vdefault
    else
      while self.nodes[node].lhs ~= WBTNIL do
        node = self.nodes[node].lhs
      end
      return self.nodes[node].key, self.nodes[node].val
    end
  end

  function wbtforestT:getmax(root: uint32, kdefault: K, vdefault: V): (K, V)
    -- Retrieves the key,value pair with the largest key in the tree `root`
    -- For an empty tree `default` is returned. O(log N)
    local node = root
    if node > #self.nodes then -- or node == WBTNIL then
      return kdefault, vdefault
    else
      while self.nodes[node].rhs ~= WBTNIL do
        node = self.nodes[node].rhs
      end
      return self.nodes[node].key, self.nodes[node].val
    end
  end

  function wbtforestT:getKV(node: uint32, defaultk: K, defaultv: V): (K, V) <inline>
    if node > #self.nodes then -- or node == WBTNIL then
      return defaultk, defaultv
    else
      return self.nodes[node].key, self.nodes[node].val
    end
  end

  function wbtforestT:getnext(root: uint32, key: K, defaultk: K, defaultv: V): (K,V)
    -- Returns the key,value pair with smallest key > `key`.
    -- It is almost inorder successor, but it also works when `key` is not present.
    -- If there is no such successor key in the tree, `default` is returned. O(log N)
    local last_lhs_from: uint32 = WBTNIL
    local node = root
    while true do
      if node > #self.nodes then -- or node == WBTNIL then
          return self:getKV(last_lhs_from, defaultk, defaultv) -- key not found
      else
        local dif = #[CompareFunc]#(key, self.nodes[node].key)
        switch dif
        case -1 then
          last_lhs_from = node
          node = self.nodes[node].lhs
        case 1 then
          node = self.nodes[node].rhs
        else -- key and self.nodes[node].key are eq
          -- return value from min node of rhs subtree, or from last_lhs_from if none
          if self.nodes[node].rhs == WBTNIL then
            return self:getKV(last_lhs_from, defaultk, defaultv)
          else
            return self:getmin(self.nodes[node].rhs, defaultk, defaultv)
          end
        end
      end
    end
    return defaultk, defaultv -- can't happen, but compiler doesn't know
  end

  function wbtforestT:getprev(root: uint32, key: K, defaultk: K, defaultv: V): (K,V)
    -- Returns the key,value pair with largest key < `key`.
    -- It is almost inorder predecessor, but it also works when `key` is not present.
    -- If there is no such predecessor key in the tree, `default` is returned. O(log N)
    local last_rhs_from: uint32 = WBTNIL
    local node = root
    while true do
      if node > #self.nodes then -- or node == WBTNIL then
          return self:getKV(last_rhs_from, defaultk, defaultv) -- key not found
      else
        local dif = #[CompareFunc]#(key, self.nodes[node].key)
        switch dif
        case -1 then
          node = self.nodes[node].lhs
        case 1 then
          last_rhs_from = node
          node = self.nodes[node].rhs
        else -- key and self.nodes[node].key are eq
          -- return value from max node of lhs subtree, or from last_rhs_from if none
          if self.nodes[node].lhs == WBTNIL then
            return self:getKV(last_rhs_from, defaultk, defaultv)
          else
            return self:getmax(self.nodes[node].lhs, defaultk, defaultv)
          end
        end
      end
    end
    return defaultk, defaultv -- can't happen, but compiler doesn't know
  end

  --[[ ************************ rank ************************ ]]

  function wbtforestT:getrank(root: uint32, key: K, default: integer): integer
    -- Retrieves the 0-based index of `key` in the tree `root` iff `key` is in the tree.
    -- Otherwise, `default` is returned. O(log N)
    local result = default
    local n: integer = 0
    local node = root
    while node ~= WBTNIL do
      local dif = #[CompareFunc]#(key, self.nodes[node].key)
      switch dif
      case -1 then
        node = self.nodes[node].lhs
      case 1 then
        n = n + 1 + self:nodesize(self.nodes[node].lhs)
        node = self.nodes[node].rhs
      else -- key and self.nodes[node].key are eq
        result = n + self:nodesize(self.nodes[node].lhs)
        return result -- break from loop
      end
    end
    return result
  end

  --[[ ************************ set operations ************************ ]]

  -- This is Adams's concat3
  --
  function wbtforestT:join3(key: K, val: V, lhs: uint32, rhs: uint32): uint32
    local result = WBTNIL
    if lhs == WBTNIL then
      result = self:insert(rhs, key, val)
    elseif rhs == WBTNIL then
      result = self:insert(lhs, key, val)
    else
      local sl = self:nodesize(lhs)
      local sr = self:nodesize(rhs)
      if (OMEGA * sl) < sr then
        result = self:balance(self:join3(key, val, lhs, self.nodes[rhs].lhs),
                              self.nodes[rhs].key, self.nodes[rhs].val, self.nodes[rhs].rhs)
      elseif (OMEGA * sr) < sl then
        result = self:balance(self.nodes[lhs].lhs, self.nodes[lhs].key, self.nodes[lhs].val,
                              self:join3(key, val, self.nodes[lhs].rhs, rhs))
      else
        result = self:newnode(lhs, key, val, rhs)
      end
    end
    return result
  end

  -- This is Adams's concat
  --
  function wbtforestT:join(lhs: uint32, rhs: uint32): uint32
    local result = WBTNIL
    if lhs == WBTNIL then
      result = rhs
    elseif rhs == WBTNIL then
      result = lhs
    else
      local key, val, rhsp = self:extractMin(rhs)
      result = self:join3(key, val, lhs, rhsp)
    end
    return result
  end

  -- This is Adams's split_lt and split_gt combined into one function, along with contains(root, key)
  --
  function wbtforestT:split(key: K, root: uint32): (uint32, boolean, uint32)
    if root == WBTNIL then
      return root, false, root
    else
      local dif = #[CompareFunc]#(key, self.nodes[root].key)
      switch dif
      case -1 then
        local l, b, r = self:split(key, self.nodes[root].lhs)
        return l, b, self:join3(self.nodes[root].key, self.nodes[root].val, r, self.nodes[root].rhs)
      case 1 then
        local l, b, r = self:split(key, self.nodes[root].rhs)
        return self:join3(self.nodes[root].key, self.nodes[root].val, self.nodes[root].lhs, l), b, r
      else -- key and self.nodes[node].key are eq
        return self.nodes[root].lhs, true, self.nodes[root].rhs
      end
    end
  end

  function wbtforestT:splitMerge(key: K, val: V, root: uint32, merge: function(k: K, v1: V, v2: V): V): (uint32, boolean, V, uint32)
    if root == WBTNIL then
      return root, false, val, root
    else
      local dif = #[CompareFunc]#(key, self.nodes[root].key)
      switch dif
      case -1 then
        local l, b, val, r = self:splitMerge(key, val, self.nodes[root].lhs, merge)
        return l, b, val, self:join3(self.nodes[root].key, self.nodes[root].val, r, self.nodes[root].rhs)
      case 1 then
        local l, b, val, r = self:splitMerge(key, val, self.nodes[root].rhs, merge)
        return self:join3(self.nodes[root].key, self.nodes[root].val, self.nodes[root].lhs, l), b, val, r
      else -- key and self.nodes[node].key are eq
        return self.nodes[root].lhs, true, merge(key, val, self.nodes[root].val), self.nodes[root].rhs
      end
    end
  end

  function wbtforestT:union(tree1: uint32, tree2: uint32): uint32
    -- Returns the union of the sets represented by the keys in `tree1` and `tree2`.
    -- When viewed as maps, returns the key,value pairs that appear in either tree; if
    -- a key appears in both trees, the value for that key is selected from `tree1`, so
    -- this function is asymmetrical for maps. If you need more comtrol over how the
    -- values are selected for duplicate keys, see `unionmerge`. O(M + N) but if the minimum
    -- key of one tree is greater than the maximum key of the other tree then O(log M)
    -- where M is the size of the larger tree.
    if tree1 == WBTNIL then
      return tree2
    elseif tree2 == WBTNIL then
      return tree1
    else
      local l, b, r = self:split(self.nodes[tree1].key, tree2)
      return self:join3(self.nodes[tree1].key, self.nodes[tree1].val,
                        self:union(self.nodes[tree1].lhs, l),
                        self:union(self.nodes[tree1].rhs, r))
    end
  end

  function wbtforestT:unionmerge(tree1: uint32, tree2: uint32, merge: function(k: K, v1: V, v2: V): V): uint32
    -- Returns the union of the sets represented by the keys in `tree1` and `tree2`.
    -- When viewed as maps, returns the key,value pairs that appear in either tree; if
    -- a key appears in both trees, the value for that key is the result of the supplied
    -- `merge` function, which is passed the common key, and the values from `tree1` and
    -- `tree2` respectively.  O(M + N) but if the minimum
    -- key of one tree is greater than the maximum key of the other tree then O(log M)
    -- where M is the size of the larger tree.
    if tree1 == WBTNIL then
      return tree2
    elseif tree2 == WBTNIL then
      return tree1
    else
      local l, b, v, r = self:splitMerge(self.nodes[tree1].key, self.nodes[tree1].val, tree2, merge)
      return self:join3(self.nodes[tree1].key, v,
                        self:unionmerge(self.nodes[tree1].lhs, l, merge),
                        self:unionmerge(self.nodes[tree1].rhs, r, merge))
    end
  end

  function wbtforestT:difference(tree1: uint32, tree2: uint32): uint32
    -- Returns the asymmetric set difference between `tree1` and `tree2`. In other words,
    -- returns the keys that are in `tree1`, but not in `tree2`.  O(M + N)
    if tree1 == WBTNIL or tree2 == WBTNIL then
      return tree1
    else
      local l, b, r = self:split(self.nodes[tree2].key, tree1)
      return self:join(self:difference(l, self.nodes[tree2].lhs),
                       self:difference(r, self.nodes[tree2].rhs))
    end
  end

  function wbtforestT:symmetricdifference(tree1: uint32, tree2: uint32): uint32
    -- Returns the symmetric set difference between `tree1` and `tree2`. In other words,
    -- returns the keys that are in `tree1`, but not in `tree2`, union the keys that are in
    -- `tree2` but not in `tree1`.  O(M + N)
    if tree1 == WBTNIL then
      return tree2
    elseif tree2 == WBTNIL then
      return tree1
    else
      local l, b, r = self:split(self.nodes[tree2].key, tree1)
      if b then
        return self:join(self:symmetricdifference(l, self.nodes[tree2].lhs),
                         self:symmetricdifference(r, self.nodes[tree2].rhs))
      else
        return self:join3(self.nodes[tree2].key, self.nodes[tree2].val,
                         self:symmetricdifference(l, self.nodes[tree2].lhs),
                         self:symmetricdifference(r, self.nodes[tree2].rhs))
      end
    end
  end

  function wbtforestT:contains(root: uint32, key: K): boolean
    -- Returns `true` if the `key` is in the tree `root`
    -- otherwise `false`. O(log N)
    local node = root
    while node ~= WBTNIL do
      local dif = #[CompareFunc]#(key, self.nodes[node].key)
      switch dif
      case -1 then
        node = self.nodes[node].lhs
      case  1 then
        node = self.nodes[node].rhs
      else -- key and self.nodes[node].key are eq
        return true -- break
      end
    end
    return false
  end

  function wbtforestT:intersection(tree1: uint32, tree2: uint32): uint32
    -- Returns the set intersection of `tree1` and `tree2`. In other words, returns the keys
    -- that are in both trees.
    -- When viewed as maps, returns the key,value pairs for keys that appear in both trees;
    -- the value each key is selected from `tree1`, so
    -- this function is asymmetrical for maps. If you need more comtrol over how the
    -- values are selected for duplicate keys, see `uintersectionmerge`. O(M + N)
    if tree1 == WBTNIL then
      return tree1
    elseif tree2 == WBTNIL then
      return tree2
    else
      local l, b, r = self:split(self.nodes[tree1].key, tree2)
      if b then
        return self:join3(self.nodes[tree1].key, self.nodes[tree1].val,
                          self:intersection(self.nodes[tree1].lhs, l),
                          self:intersection(self.nodes[tree1].rhs, r))
      else
        return self:join(self:intersection(self.nodes[tree1].lhs, l),
                         self:intersection(self.nodes[tree1].rhs, r))
      end
    end
  end

  function wbtforestT:intersectionmerge(tree1: uint32, tree2: uint32, merge: function(k: K, v1: V, v2: V): V): uint32
    -- Returns the set intersection of `tree1` and `tree2`. In other words, returns the keys
    -- that are in both trees.
    -- When viewed as maps, returns the key,value pairs for keys that appear in both trees;
    -- the value for each key is the result of the supplied
    -- `merge` function, which is passed the common key, and the values from `tree1` and
    -- `tree2` respectively.  O(M + N)
    if tree1 == WBTNIL then
      return tree1
    elseif tree2 == WBTNIL then
      return tree2
    else
      local l, b, v, r = self:splitMerge(self.nodes[tree1].key, self.nodes[tree1].val, tree2, merge)
      if b then
        return self:join3(self.nodes[tree1].key, v,
                          self:intersectionmerge(self.nodes[tree1].lhs, l, merge),
                          self:intersectionmerge(self.nodes[tree1].rhs, r, merge))
      else
        return self:join(self:intersectionmerge(self.nodes[tree1].lhs, l, merge),
                         self:intersectionmerge(self.nodes[tree1].rhs, r, merge))
      end
    end
  end

  function wbtforestT:issubset(tree1: uint32, tree2: uint32): boolean
    -- Returns true iff the keys in `tree1` form a subset of the keys in `tree2`. In other words,
    -- if all the keys that are in `tree1` are also in `tree2`. O(N) where N is `len(tree1)`
    -- Use `ispropersubset` instead to determins that there are keys in `tree2` that are not in `tree1`.
    if tree1 == WBTNIL then
      return true
    elseif self:nodesize(tree1) > self:nodesize(tree2) then
      return false
    else
      -- tree2 is not nil or else the above length test would have been true
      local dif = #[CompareFunc]#(self.nodes[tree1].key, self.nodes[tree2].key)
      switch dif
      case -1 then
        return self:issubset(self.nodes[tree1].lhs, self.nodes[tree2].lhs) and
                self:contains(tree2, self.nodes[tree1].key) and
                self:issubset(self.nodes[tree1].rhs, tree2)
      case 1 then
        return self:issubset(self.nodes[tree1].rhs, self.nodes[tree2].rhs) and
                self:contains(tree2, self.nodes[tree1].key) and
                self:issubset(self.nodes[tree1].lhs, tree2)
      else -- self.nodes[tree1].key and self.nodes[tree2].key are eq
        return self:issubset(self.nodes[tree1].lhs, self.nodes[tree2].lhs) and
                self:issubset(self.nodes[tree1].rhs, self.nodes[tree2].rhs)
      end
    end
  end

  function wbtforestT:disjoint(tree1: uint32, tree2: uint32): boolean
    -- Returns true iff `tree1` and `tree2` have no keys in common. O(N) where N is
    -- `len(tree1)`
    if (tree1 ~= WBTNIL) and (tree2 ~= WBTNIL) then
      local dif = #[CompareFunc]#(self.nodes[tree1].key, self.nodes[tree2].key)
      switch dif
      case -1 then
        if not self:disjoint(self.nodes[tree1].lhs, self.nodes[tree2].lhs) then return false end
        if self:contains(tree2, self.nodes[tree1].key) then return false end
        return self:disjoint(self.nodes[tree1].rhs, tree2)
      case 1 then
        if not self:disjoint(self.nodes[tree1].rhs, self.nodes[tree2].rhs) then return false end
        if self:contains(tree2, self.nodes[tree1].key) then return false end
        return self:disjoint(self.nodes[tree1].lhs, tree2)
      else -- self.nodes[tree1].key and self.nodes[tree2].key are eq
        return false
      end
    end
    return true
  end

  function wbtforestT:ispropersubset(tree1: uint32, tree2: uint32): boolean
    -- Returns true iff the keys in `tree1` form a proper subset of the keys in `tree2`.
    -- In other words, if all the keys that are in `tree1` are also in `tree2`, but there are
    -- keys in `tree2` that are not in `tree1`.  O(N) where N is `len(tree1)`
    return self:issubset(tree1, tree2) and self:nodesize(tree1) < self:nodesize(tree2)
  end

  function wbtforestT:setequal(tree1: uint32, tree2: uint32): boolean
    -- Returns true if both `tree1` and `tree2` have the same keys.
    return self:nodesize(tree1) == self:nodesize(tree2) and self:issubset(tree1, tree2)
  end

  --[[ ************************ wbtmap ************************ ]]

  function wbtforestT:makewbtmap_(node: uint32): *wbtmapT
    local wbt: *wbtmapT =  (@*wbtmapT)(self.allocator:new(@wbtmapT))
    local rootp: *wbtrootT = (@*wbtrootT)(self.allocator:xalloc0(#wbtrootT))
    rootp.node = node
    -- insert wbtroot into doubly linked list
    self:preprootslist()
    rootp.next = self.roots.next
    self.roots.next = rootp
    rootp.prev = &self.roots
    rootp.next.prev = rootp
    -- fill out result
    wbt.trail = self.trail
    wbt.root = rootp
    --PRINTF!('Link %p <- %p -> %p\n', rootp.prev, rootp, rootp.next)
    return wbt
  end

  function wbtforestT:makewbtmap(): *wbtmapT
    return self:makewbtmap_(WBTNIL)
  end

--[[ same as nodesize
  function wbtforestT:wbtsize(node: uint32): uint32
    if node < #self.nodes then
      return self.nodes[node].siz
    else
      return 0
    end
  end
]]

  function wbtmapT:getforest() : *wbtforestT <inline>
    local forest = self.trail.forest
    if forest == nilptr then
      panic("Attempt to access destroy'd wbtforest")
    end
    return forest
  end

  function wbtmapT:insert(k: K, v: V): *wbtmapT
    local forest = self:getforest()
    local node: uint32 = forest:insert(self.root.node, k, v)
    forest.wip_n = 0 -- no more wip
    return forest:makewbtmap_(node)
  end

  function wbtmapT:get(k: K, default: V): V
    local forest = self:getforest()
    return forest:get(self.root.node, k, default)
  end

  function wbtmapT:delete(k: K): *wbtmapT
    local forest = self:getforest()
    local node: uint32 = forest:delete(self.root.node, k)
    forest.wip_n = 0 -- no more wip
    return forest:makewbtmap_(node)
  end

  function wbtmapT:delmin(): *wbtmapT
    local forest = self:getforest()
    local node: uint32 = forest:delmin(self.root.node)
    forest.wip_n = 0 -- no more wip
    return forest:makewbtmap_(node)
  end

  function wbtmapT:delmax(): *wbtmapT
    local forest = self:getforest()
    local node: uint32 = forest:delmax(self.root.node)
    forest.wip_n = 0 -- no more wip
    return forest:makewbtmap_(node)
  end

  function wbtmapT:getNth(index: integer, kdefault: K, vdefault: V): (K, V)
    local forest = self:getforest()
    return forest:getNth(self.root.node, index, kdefault, vdefault)
  end

  function wbtmapT:getmin(kdefault: K, vdefault: V): (K, V)
    local forest = self:getforest()
    return forest:getmin(self.root.node, kdefault, vdefault)
  end

  function wbtmapT:getmax(kdefault: K, vdefault: V): (K, V)
    local forest = self:getforest()
    return forest:getmax(self.root.node, kdefault, vdefault)
  end

  function wbtmapT:getnext(k: K, kdefault: K, vdefault: V): (K, V)
    local forest = self:getforest()
    return forest:getnext(self.root.node, k, kdefault, vdefault)
  end

  function wbtmapT:getprev(k: K, kdefault: K, vdefault: V): (K, V)
    local forest = self:getforest()
    return forest:getprev(self.root.node, k, kdefault, vdefault)
  end

  function wbtmapT:getrank(k: K, default: integer): integer
    local forest = self:getforest()
    return forest:getrank(self.root.node, k, default)
  end

  function wbtmapT:contains(k: K): boolean
    local forest = self:getforest()
    return forest:contains(self.root.node, k)
  end

  function wbtmapT:getforests(wbt2: *wbtmapT): *wbtforestT <inline>
    local forest = self.trail.forest
    if forest == nilptr then
      panic("Attempt to access destroy'd wbtforest")
    end
    assert(forest == wbt2.trail.forest, "Attempt to combine wbtmapTs from different wbtforestTs")
    return forest
  end

  function wbtmapT:union(wbt2: *wbtmapT): *wbtmapT
    local forest = self:getforests(wbt2)
    local node: uint32 = forest:union(self.root.node, wbt2.root.node)
    forest.wip_n = 0 -- no more wip
    return forest:makewbtmap_(node)
  end

  function wbtmapT:unionmerge(wbt2: *wbtmapT, merge: function(k: K, v1: V, v2: V): V): *wbtmapT
    local forest = self:getforests(wbt2)
    local node: uint32 = forest:unionmerge(self.root.node, wbt2.root.node, merge)
    forest.wip_n = 0 -- no more wip
    return forest:makewbtmap_(node)
  end

  function wbtmapT:difference(wbt2: *wbtmapT): *wbtmapT
    local forest = self:getforests(wbt2)
    local node: uint32 = forest:difference(self.root.node, wbt2.root.node)
    forest.wip_n = 0 -- no more wip
    return forest:makewbtmap_(node)
  end

  function wbtmapT:symmetricdifference(wbt2: *wbtmapT): *wbtmapT
    local forest = self:getforests(wbt2)
    local node: uint32 = forest:symmetricdifference(self.root.node, wbt2.root.node)
    forest.wip_n = 0 -- no more wip
    return forest:makewbtmap_(node)
  end

  function wbtmapT:intersection(wbt2: *wbtmapT): *wbtmapT
    local forest = self:getforests(wbt2)
    local node: uint32 = forest:intersection(self.root.node, wbt2.root.node)
    forest.wip_n = 0 -- no more wip
    return forest:makewbtmap_(node)
  end

  function wbtmapT:intersectionmerge(wbt2: *wbtmapT, merge: function(k: K, v1: V, v2: V): V): *wbtmapT
    local forest = self:getforests(wbt2)
    local node: uint32 = forest:intersectionmerge(self.root.node, wbt2.root.node, merge)
    forest.wip_n = 0 -- no more wip
    return forest:makewbtmap_(node)
  end

  function wbtmapT:issubset(wbt2: *wbtmapT): boolean
    local forest = self:getforests(wbt2)
    return forest:issubset(self.root.node, wbt2.root.node)
  end

  function wbtmapT:ispropersubset(wbt2: *wbtmapT): boolean
    local forest = self:getforests(wbt2)
    return forest:ispropersubset(self.root.node, wbt2.root.node)
  end

  function wbtmapT:setequal(wbt2: *wbtmapT): boolean
    local forest = self:getforests(wbt2)
    return forest:setequal(self.root.node, wbt2.root.node)
  end

  function wbtmapT:disjoint(wbt2: *wbtmapT): boolean
    local forest = self:getforests(wbt2)
    return forest:disjoint(self.root.node, wbt2.root.node)
  end


function wbtmapT:__len(): isize
    local forest = self:getforest()
    return forest:nodesize(self.root.node)
  end

  --[[ ************************ iterate ************************ ]]

  -- wbtree iterator
  local wbtmap_iteratorT: type = @record{
    forest: *wbtforestT,
    stack: span(uint32),
    stidx: uint32,
    next: uint32
  }

  --[[
  Advances the wbtmapT container iterator returning its key and value.

  *Remarks*: The input `key` is actually ignored.
  ]]
  function wbtmap_iteratorT:next(key: K): (boolean, K, V)
    local curr = self.next
    if unlikely(self.stidx == WBTNIL) then
      -- init the stack; curr is root
      self.stidx = 0
    elseif curr ~= WBTNIL then
      -- go right from last yielded node
      curr = self.forest.nodes[curr].rhs
    end
    if curr ~= WBTNIL or self.stidx > 0 then
      while curr ~= WBTNIL do -- push node before going left
        if unlikely(self.stidx >= #self.stack) then
          self.stack = self.forest.allocator:xspanrealloc(self.stack, 2 * #self.stack)
        end
        self.stack[self.stidx] = curr
        self.stidx = self.stidx + 1
        curr = self.forest.nodes[curr].lhs
      end
      -- at the leftmost node; curr is nil; pop
      self.stidx = self.stidx - 1
      curr = self.stack[self.stidx]
      self.next = curr
      return true, self.forest.nodes[curr].key, self.forest.nodes[curr].val
    else
      -- it is an empty tree or we're at the end
      -- dealloc stack
      self.forest.allocator:spandealloc(self.stack)
      self.stack = (@span(uint32))()
      return false, (@K)(), (@V)()
    end
  end

  --[[
  Advances the wbtmapT container reverse iterator returning its key and value.

  *Remarks*: The input `key` is actually ignored.
  ]]
  function wbtmap_iteratorT:revnext(key: K): (boolean, K, V)
    local curr = self.next
    if unlikely(self.stidx == WBTNIL) then
      -- init the stack; curr is root
      self.stidx = 0
    elseif curr ~= WBTNIL then
      -- go left from last yielded node
      curr = self.forest.nodes[curr].lhs
    end
    if curr ~= WBTNIL or self.stidx > 0 then
      while curr ~= WBTNIL do -- push node before going right
        if unlikely(self.stidx >= #self.stack) then
          self.stack = self.forest.allocator:xspanrealloc(self.stack, 2 * #self.stack)
        end
        self.stack[self.stidx] = curr
        self.stidx = self.stidx + 1
        curr = self.forest.nodes[curr].rhs
      end
      -- at the righttmost node; curr is nil; pop
      self.stidx = self.stidx - 1
      curr = self.stack[self.stidx]
      self.next = curr
      return true, self.forest.nodes[curr].key, self.forest.nodes[curr].val
    else
      -- it is an empty tree or we're at the end
      -- dealloc stack
      self.forest.allocator:spandealloc(self.stack)
      self.stack = (@span(uint32))()
      return false, (@K)(), (@V)()
    end
  end

  -- Support using `pairs()` to iterate the wbtmapT container.
  function wbtmapT:__pairs(): (auto, wbtmap_iteratorT, K) <inline>
    local forest = self:getforest()
    return wbtmap_iteratorT.next,
           (@wbtmap_iteratorT){forest = forest,
                               stack = forest.allocator:xspanalloc(uint32, INIT_CAPACITY),
                               stidx = WBTNIL,
                               next = self.root.node},
           (@K)()
  end

  -- Support using `revpairs()` to iterate the wbtmapT container.
  function wbtmapT:revpairs(): (auto, wbtmap_iteratorT, K) <inline>
    local forest = self:getforest()
    return wbtmap_iteratorT.revnext,
           (@wbtmap_iteratorT){forest = forest,
                               stack = forest.allocator:xspanalloc(uint32, INIT_CAPACITY),
                               stidx = WBTNIL,
                               next = self.root.node},
           (@K)()
  end

  --[[ ************************ testing ************************ ]]

## if WBTFOREST_UNITTEST then
  function wbtforestT:treetostring(n: uint32): string
    -- assume int keys
    if n == WBTNIL then
      return ""
    end
    local root = self.nodes[n]
    return string.format("(%s %d %s)",
             self:treetostring(root.lhs), root.key, self:treetostring(root.rhs))
  end
  function wbtmapT:treetostring(): string
    local forest = self:getforest()
    return forest:treetostring(self.root.node)
  end
## end


  -- TODO

--  function wbtmapT:balanced_(node: uint32): isize
--    if node == WBTNIL then return 0 end
--    local sl: uint32 = self:nodesize_(self.nodes[node].l)
--    local sr: uint32 = self:nodesize_(self.nodes[node].r)
--    local sz: uint32 = self:nodesize_(node)
--    if (sl + 1 + sr) ~= sz then
--      io.printf("Error in wbtmap balanced: %u != %u + 1 + %u; (%u %u)\n", sz, sl, sr, self.nodes[node].l, self.nodes[node].r)
--      return -1
--    end
--    if (sl + sr) <= 1 then
--      -- balanced
--    elseif sr > (OMEGA * sl) then
--      io.printf("Error in wbtmap balanced: sr %u > omega * %u\n", sr, sl)
--      return -1
--    elseif sl > (OMEGA * sr) then
--      io.printf("Error in wbtmap balanced: sl %u > omega * %u\n", sl, sr)
--      return -1
--    end
--    local slb: isize = self:balanced_(self.nodes[node].l)
--    local srb: isize = self:balanced_(self.nodes[node].r)
--    if (slb < 0) or (sl ~= slb) then
--      if (slb >= 0) then io.printf("Error in wbtmap balanced: sl %u != %lld\n", sl, slb) end
--      return -1
--    end
--    if (srb < 0) or (sr ~= srb) then
--      if (srb >= 0) then io.printf("Error in wbtmap balanced:  sr %u != %lld\n", sr, srb) end
--      return -1
--    end
--    return sz
--  end
--
--  -- Unit test function returns `true` if the tree is balanced which should always be true
--  function wbtmapT:isbalanced(): boolean
--    local sz: isize = self:balanced_(self.root)
--    if self.root < self.bump then
--      return (sz > 0) and (sz == self:nodesize_(self.root))
--    else
--      return (sz == 0)
--    end
--  end
--
--  ##end

  ## return wbtforestT
## end

--[[
Generic used to instantiate a wbt map type in the form of `wbtforest(K, V, CompareFunc, Allocator)`.

Argument `K` is the key type for the wbt maps within the forest.
Argument `V` is the value type for the wbt maps within the forest.
Argument `CompareFunc` is a function to compare two keys in the sense of __lt,
in case absent then `__lt` is used.
Argument `Allocator` is an allocator type for the container storage,
in case absent then then `DefaultAllocator` is used.
]]
global wbtforest: type = #[generalize(make_wbtforestT)]#

return wbtforest


